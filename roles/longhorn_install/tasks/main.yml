- name: Validate runner host
  ansible.builtin.assert:
    that:
      - longhorn_runner_host is defined
      - longhorn_runner_host | length > 0
    fail_msg: "longhorn_runner_host is not set (expected groups['k3s_servers'][0])."

- name: Validate worker nodes group is populated
  ansible.builtin.assert:
    that:
      - longhorn_worker_nodes is defined
      - longhorn_worker_nodes | length > 0
    fail_msg: "longhorn_worker_nodes is empty. Set longhorn_worker_nodes to your worker group (e.g., groups['k3s_agents'])."
  when:
    - longhorn_components_workers_only | bool or longhorn_label_workers | bool or longhorn_disable_scheduling_on_controllers | bool

- name: Assert kubeconfig exists on runner host
  ansible.builtin.stat:
    path: "{{ longhorn_kubeconfig_path }}"
  register: longhorn_kcfg
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"

- name: Fail if kubeconfig missing on runner host
  ansible.builtin.assert:
    that:
      - longhorn_kcfg.stat.exists
    fail_msg: "k3s kubeconfig not found at {{ longhorn_kubeconfig_path }} on {{ longhorn_runner_host }}. k3s server install may not have completed."
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"

- name: Ensure Longhorn namespace exists
  ansible.builtin.shell: |
    set -euo pipefail
    kubectl --kubeconfig {{ longhorn_kubeconfig_path }} get ns {{ longhorn_namespace }} >/dev/null 2>&1 || \
      kubectl --kubeconfig {{ longhorn_kubeconfig_path }} create ns {{ longhorn_namespace }}
  args:
    executable: /bin/bash
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"

# -----------------------------------------
# Workers-only: label workers BEFORE Helm so nodeSelectors can schedule
# -----------------------------------------
- name: Label worker nodes for Longhorn ({{ longhorn_worker_label_key }}={{ longhorn_worker_label_value }})
  ansible.builtin.shell: |
    set -euo pipefail
    {% for n in longhorn_worker_nodes %}
    kubectl --kubeconfig {{ longhorn_kubeconfig_path }} label node {{ n }} {{ longhorn_worker_label_key }}={{ longhorn_worker_label_value }} --overwrite
    {% endfor %}
  args:
    executable: /bin/bash
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"
  when: longhorn_label_workers | bool

# -------------------------------------------------------------------
# Build effective Helm values (merge user values + workers-only selectors)
# -------------------------------------------------------------------
- name: Build effective Helm values (merge user values + optional workers-only selectors)
  ansible.builtin.set_fact:
    longhorn_helm_values_effective: >-
      {{
        (longhorn_helm_values | default({}))
        | combine(
            (
              {
                'longhornManager': {
                  'nodeSelector': { (longhorn_worker_label_key): (longhorn_worker_label_value) }
                },
                'csi': {
                  'nodeSelector': { (longhorn_worker_label_key): (longhorn_worker_label_value) }
                },
                'longhornUI': {
                  'nodeSelector': { (longhorn_worker_label_key): (longhorn_worker_label_value) }
                }
              }
              if (longhorn_components_workers_only | bool)
              else {}
            ),
            recursive=True
          )
      }}
  run_once: true

- name: Add Longhorn Helm repo + update
  ansible.builtin.shell: |
    set -euo pipefail
    helm repo add {{ longhorn_helm_repo_name }} {{ longhorn_helm_repo_url }} 2>/dev/null || true
    helm repo update
  args:
    executable: /bin/bash
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"

- name: Write Helm values file if needed
  ansible.builtin.copy:
    dest: /tmp/longhorn-values.yml
    content: "{{ longhorn_helm_values_effective | to_nice_yaml }}"
    mode: "0600"
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"
  when: longhorn_helm_values_effective | length > 0

- name: Install/upgrade Longhorn via Helm (uses runner kubeconfig)
  ansible.builtin.shell: |
    set -euo pipefail

    args=(
      upgrade --install {{ longhorn_release_name }} {{ longhorn_chart_name }}
      --namespace {{ longhorn_namespace }}
      --create-namespace
    )

    {% if longhorn_chart_version | length > 0 %}
    args+=( --version {{ longhorn_chart_version }} )
    {% endif %}

    {% if longhorn_helm_values_effective | length > 0 %}
    args+=( -f /tmp/longhorn-values.yml )
    {% endif %}

    helm "${args[@]}"
  args:
    executable: /bin/bash
  environment:
    KUBECONFIG: "{{ longhorn_kubeconfig_path }}"
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"
  changed_when: true

# -----------------------------------------
# Wait for the things that must exist for a healthy install
# -----------------------------------------
- name: Wait for Longhorn manager DaemonSet to be ready
  ansible.builtin.shell: |
    set -euo pipefail
    kubectl --kubeconfig {{ longhorn_kubeconfig_path }} -n {{ longhorn_namespace }} \
      rollout status ds/longhorn-manager --timeout={{ longhorn_wait_timeout }}
  args:
    executable: /bin/bash
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"

- name: Wait for Longhorn UI Deployment to be available (if present)
  ansible.builtin.shell: |
    set -euo pipefail
    if kubectl --kubeconfig {{ longhorn_kubeconfig_path }} -n {{ longhorn_namespace }} get deploy longhorn-ui >/dev/null 2>&1; then
      kubectl --kubeconfig {{ longhorn_kubeconfig_path }} -n {{ longhorn_namespace }} \
        wait --for=condition=Available deploy/longhorn-ui --timeout={{ longhorn_wait_timeout }}
    else
      echo "Skip: deploy/longhorn-ui not found"
    fi
  args:
    executable: /bin/bash
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"

- name: Wait for Longhorn CSI plugin DaemonSet to be ready (if present)
  ansible.builtin.shell: |
    set -euo pipefail
    if kubectl --kubeconfig {{ longhorn_kubeconfig_path }} -n {{ longhorn_namespace }} get ds longhorn-csi-plugin >/dev/null 2>&1; then
      kubectl --kubeconfig {{ longhorn_kubeconfig_path }} -n {{ longhorn_namespace }} \
        rollout status ds/longhorn-csi-plugin --timeout={{ longhorn_wait_timeout }}
    else
      echo "Skip: ds/longhorn-csi-plugin not found"
    fi
  args:
    executable: /bin/bash
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"

# -----------------------------------------
# Workers-only storage scheduling enforcement (Longhorn-native)
# Disable scheduling on controller nodes.longhorn.io
# -----------------------------------------
- name: Wait for Longhorn Node CRDs to exist (nodes.longhorn.io)
  ansible.builtin.shell: |
    set -euo pipefail
    kubectl --kubeconfig {{ longhorn_kubeconfig_path }} get crd nodes.longhorn.io >/dev/null
  args:
    executable: /bin/bash
  register: _lh_nodes_crd
  retries: 30
  delay: 5
  until: _lh_nodes_crd.rc == 0
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"
  when: longhorn_disable_scheduling_on_controllers | bool

- name: Disable Longhorn scheduling on controllers (allowScheduling=false)
  ansible.builtin.shell: |
    set -euo pipefail
    for n in {{ longhorn_controller_nodes | join(' ') }}; do
      kubectl --kubeconfig {{ longhorn_kubeconfig_path }} -n {{ longhorn_namespace }} \
        patch nodes.longhorn.io "$n" --type=merge -p '{"spec":{"allowScheduling":false}}' || true
    done
  args:
    executable: /bin/bash
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"
  when:
    - longhorn_disable_scheduling_on_controllers | bool
    - longhorn_controller_nodes | length > 0

# --------------------------------
# StorageClasses (default + HA)
# --------------------------------
- name: Manage StorageClasses (default + HA)
  when: longhorn_manage_storageclasses | bool
  block:

    - name: Build StorageClass manifests (as dictionaries)
      ansible.builtin.set_fact:
        longhorn_sc_default_obj: >-
          {{
            {
              'apiVersion': 'storage.k8s.io/v1',
              'kind': 'StorageClass',
              'metadata': {
                'name': longhorn_default_storageclass_name,
                'annotations': (
                  {'storageclass.kubernetes.io/is-default-class': 'true'}
                  if (longhorn_set_default_storageclass | bool)
                  else {}
                )
              },
              'provisioner': 'driver.longhorn.io',
              'reclaimPolicy': (longhorn_default_reclaim_policy | default('Delete')),
              'volumeBindingMode': (longhorn_default_volume_binding_mode | default('Immediate')),
              'allowVolumeExpansion': True,
              'parameters': {
                'numberOfReplicas': (longhorn_default_replica_count | string),
                'staleReplicaTimeout': (longhorn_default_stale_replica_timeout | string),
                'fsType': (longhorn_default_fs_type | default('ext4'))
              }
            }
          }}
        longhorn_sc_ha_obj: >-
          {{
            {
              'apiVersion': 'storage.k8s.io/v1',
              'kind': 'StorageClass',
              'metadata': {'name': longhorn_ha_storageclass_name},
              'provisioner': 'driver.longhorn.io',
              'reclaimPolicy': (longhorn_ha_reclaim_policy | default('Delete')),
              'volumeBindingMode': (longhorn_ha_volume_binding_mode | default('Immediate')),
              'allowVolumeExpansion': True,
              'parameters': {
                'numberOfReplicas': (longhorn_ha_replica_count | string),
                'staleReplicaTimeout': (longhorn_ha_stale_replica_timeout | string),
                'fsType': (longhorn_ha_fs_type | default('ext4'))
              }
            }
          }}
      run_once: true

    - name: Render default StorageClass manifest
      ansible.builtin.copy:
        dest: /tmp/longhorn-sc-default.yaml
        mode: "0644"
        content: "{{ longhorn_sc_default_obj | to_nice_yaml }}"
      run_once: true
      delegate_to: "{{ longhorn_runner_host }}"

    - name: Apply default StorageClass
      ansible.builtin.command:
        argv:
          - kubectl
          - --kubeconfig
          - "{{ longhorn_kubeconfig_path }}"
          - apply
          - -f
          - /tmp/longhorn-sc-default.yaml
      run_once: true
      delegate_to: "{{ longhorn_runner_host }}"

    - name: Render HA StorageClass manifest
      ansible.builtin.copy:
        dest: /tmp/longhorn-sc-ha.yaml
        mode: "0644"
        content: "{{ longhorn_sc_ha_obj | to_nice_yaml }}"
      run_once: true
      delegate_to: "{{ longhorn_runner_host }}"
      when: longhorn_create_ha_storageclass | bool

    - name: Apply HA StorageClass
      ansible.builtin.command:
        argv:
          - kubectl
          - --kubeconfig
          - "{{ longhorn_kubeconfig_path }}"
          - apply
          - -f
          - /tmp/longhorn-sc-ha.yaml
      run_once: true
      delegate_to: "{{ longhorn_runner_host }}"
      when: longhorn_create_ha_storageclass | bool

    - name: Unset chart-created StorageClass as default (safe)
      ansible.builtin.shell: |
        set -euo pipefail
        kubectl --kubeconfig {{ longhorn_kubeconfig_path }} patch storageclass {{ longhorn_chart_storageclass_name }} \
          -p '{"metadata":{"annotations":{"storageclass.kubernetes.io/is-default-class":"false"}}}' || true
      args:
        executable: /bin/bash
      run_once: true
      delegate_to: "{{ longhorn_runner_host }}"
      when: longhorn_unset_chart_default_storageclass | bool

# -------------------------
# FIXED: Show Longhorn status
# -------------------------
- name: Show Longhorn status
  ansible.builtin.shell: |
    set -euo pipefail
    kubectl --kubeconfig {{ longhorn_kubeconfig_path }} -n {{ longhorn_namespace }} get pods -o wide
    echo
    kubectl --kubeconfig {{ longhorn_kubeconfig_path }} get storageclass
    echo
    kubectl --kubeconfig {{ longhorn_kubeconfig_path }} -n {{ longhorn_namespace }} get nodes.longhorn.io \
      -o 'custom-columns=NAME:.metadata.name,ALLOW:.spec.allowScheduling,READY:.status.conditions[?(@.type=="Ready")].status'
  args:
    executable: /bin/bash
  run_once: true
  delegate_to: "{{ longhorn_runner_host }}"
  changed_when: false